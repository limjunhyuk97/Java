# 연산자와 연산식

### 연산시 주의점

  - 부호연산의 결과는 int이기에, (byte형 피연산자) = -(byte형 피연산자) 식으로 선언할 수 없다.
  - 부호연산의 결과값은 int형에 저장해야만 한다.
```java

byte num = 30;
byte num2 = -num; // 불가능.

```
  - 증감연산자++, --는 boolean 타입을 제외한 모든 기본타입에 적용할 수 있다.. (실수타입에도 적용할 수 있다는 것!)
  - 리터럴간의 연산은 컴파일단계에서 수행되므로, 타입변환이 없다
  - 변수간의 연산은, 타입변환이 있다.
  
```java
char a1 = 'A';
char a2 = 'A' + 1; O // 리터럴간의 연산은 타입변환따위 없다.
char a3 = a1 + 1;  X // a1이 int로 변경되므로, 컴파일 에러가 발생.
char a3 = (char)(a1 + 1); //  강제형변환이 필요한 것이다.
int a3 = a1 + 1;   O // a1이 int로 변경되므로, 다음과 같은 연산이 맞음.
```

  - == 연산은 기본타입에서 모두 쓸수 있고, String문자열 타입에서는 .equals() 함수(메서드)를 이용한다.
  - 실수의 == 연산에서 유의할 점
  
```java
float num1 = 2.3f;
double num2 = 2.3;
num1 == num2  // false 도출. 부동소숫점의 정확도 차이 발생.
num1 == (float)num2   // true 도출.
(double)num1 == num2  // false 도출. 덜정확한 범위를 더 정확한 범위에 맞출 수는 없는법.
```

  - += *= 같은 복합대입연산자는 자동으로 형변환을 진행해준다.

```java

// 다음 두 연산은 같은 결과를 도출함.
short num = 10;
num = (short)(num + 5L);
num += 5L;

```

  - 논리연산자와 SCE (Short Circuit Evaluation)
    - 논리 연산자의 좌측을 통해서 이미 결과가 예측되는 경우, 우측의 계산을 수행하지 않는 것이다.
    - 그렇기에 코드를 나눠서 작성하는 것이 좋다.

```java

int num1 = 0, num2 = 0;

// 이미 ((num1+=10) < 0)의 연산이 거짓이기에, 전체 연산이 거짓이므로 num1 = 10, num2 = 0이 된다. (num2의 연산이 수행되지 않는다.)
if( ((num1+=10) < 0) && ((num2+=10) > 0))

// 이미 ((num1+=10) > 0)의 연산이 참이기에, 전체 연산이 참이므로 num1 = 20, num2 = 0이 된다. (num2의 연산이 수행되지 않는다.)
if( ((num1+=10) > 0) || ((num2+=10) > 0))

```

  - 비트 쉬프트 연산
    - 상수, 변수 \<< 상수, 변수 : 왼쪽으로 밀고, 빈공간 0으로 채움 (2배 효과)
    - 상수, 변수 \>> 상수, 변수 : 오른쪽으로 밀고, 빈공간 부호에 맞게 채움 (음수면 1채우고, 양수면 0 채움 : 1/2배 효과)
    - 상수, 변수 \>>> 상수, 변수 : 오른쪽으로 밀고, 빈공간 0으로 채움

  - 비트 복합 대입 연산자
    - 비트 연산자
      - \<< \>> >>> &(AND) ^(XOR) |(OR) ~(NOT)
    - 비트 복합 대입 연산자
      - &= ^= |= <<= >>= >>>=


